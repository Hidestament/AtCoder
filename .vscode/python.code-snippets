{
	// Place your AtCoder ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Union Find Tree": {
		"prefix": "unionfindtree",
		"body": [
		"class UnionFindTree:",
		"\tdef __init__(self, n):",
		"\t\tself.parents = [-1] * n",
		"",
		"\tdef find(self, x):",
		"\t\tif self.parents[x] < 0:",
		"\t\t\treturn x",
		"\t\telse:",
		"\t\t\tself.parents[x] = self.find(self.parents[x])",
		"\t\t\treturn self.find(self.parents[x])",
		"",
		"\tdef union(self, x, y):",
		"\t\tx = self.find(x)",
		"\t\ty = self.find(y)",
		"\t\tif x == y:",
		"\t\t\treturn",
		"\t\tif self.parents[x] > self.parents[y]:",
		"\t\t\tx, y = y, x",
		"\t\tself.parents[x] += self.parents[y]",
		"\t\tself.parents[y] = x",
		"",
		"\tdef same_check(self, x, y):",
		"\t\treturn self.find(x) == self.find(y)",
		"",
		"\tdef size(self, x):",
		"\t\treturn -1 * self.parents[self.find(x)]",
		"",
		],
		"description": "Union Find Tree"
	},
	"list input": {
		"prefix": ["input", "list(map(int, input()))"],
		"body": [
		"list(map(int, input().split()))",
		],
		"description": "list input"
	},
	"recursion limit": {
		"prefix": ["sys", "import sys"],
		"body": [
		"import sys",
		"sys.setrecursionlimit(10**7)",
		],
		"description": "update recursion limit"
	},
	"int(input())": {
		"prefix": "int(input())",
		"body": [
		"int(input())",
		],
		"description": "int input"
	},
	"str(input())": {
		"prefix": "str(input())",
		"body": [
		"str(input())",
		],
		"description": "string input"
	},
	"map(int, input().split())": {
		"prefix": "map(int, input().split())",
		"body": [
		"map(int, input().split())",
		],
		"description": "Input of Multiple Integers"
	},
	"popcount": {
		"prefix": "popcount",
		"body": [
		"def popcount(x):",
		"\t'''xの立っているビット数をカウントする関数",
		"\t(xは64bit整数)'''",
		"",
		"\t# 2bitごとの組に分け、立っているビット数を2bitで表現する",
		"\tx = x - ((x >> 1) & 0x5555555555555555)",
		"",
		"\t# 4bit整数に 上位2bit + 下位2bit を計算した値を入れる",
		"\tx = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)",
		"",
		"\tx = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f # 8bitごと",
		"\tx = x + (x >> 8) # 16bitごと",
		"\tx = x + (x >> 16) # 32bitごと",
		"\tx = x + (x >> 32) # 64bitごと = 全部の合計",
		"\treturn x & 0x0000007f",
		],
		"description": "2進数展開した整数のうち、1が立っている箇所を数える"
	},
	"template": {
		"prefix": "template",
		"body": [
		"\"\"\"",
		"問題名",
		"問題リンク: ",
		"\"\"\"",
		],
		"description": "AtCoderやるときのテンプレート"
	},
	"graph input": {
		"prefix": "graph input",
		"body": [
		"graph = [[] for _ in range(N)]",
		"for _ in range(M):",
		"\tu, v = map(int, input().split())",
		"\tu -= 1",
		"\tv -= 1",
		"\tgraph[u].append(v)",
		"\tgraph[v].append(u)",
		],
		"description": "input of G = (N, M)"
	},
	"Binary Indexed Tree": {
		"prefix": "BIT",
		"body": [
		"class BinaryIndexedTree:",
		"\t\"\"\"",
		"\tA = [a0, a1, a2, ..., an-1]",
		"\t元のAの配列は0-indexだが, BIT上では1-indexで扱う",
		"\t\"\"\"",
		"",
		"\tdef __init__(self, n=10**6):",
		"\t\tself.size = n + 1",
		"\t\tself.tree = [0] * (n + 1)",
		"\t\tself.depth = n.bit_length()",
		"",
		"\tdef update(self, i, x):",
		"\t\t\"\"\"",
		"\t\tai += x を する",
		"\t\ti: 0-index",
		"\t\t\"\"\"",
		"\t\t# 1-indexに直す",
		"\t\tpos = i + 1",
		"\t\twhile pos <= self.size:",
		"\t\t\tself.tree[pos] += x",
		"\t\t\t# 真上の位置は, iにiのLSBを加えたモノ",
		"\t\t\tpos += pos & -pos",
		"",
		"\tdef sum(self, i):",
		"\t\t\"\"\"",
		"\t\ta[0] + a[1] + ... + a[i] を 求める",
		"\t\ti は 0-index",
		"\t\t\"\"\"",
		"\t\tpos = i + 1",
		"\t\ts = 0",
		"\t\twhile pos > 0:",
		"\t\t\ts += self.tree[pos]",
		"\t\t\t# 左上は i に iのLSBを引いたモノ",
		"\t\t\tpos -= pos & -pos",
		"\t\treturn s",
		"",
		"\tdef sum_range(self, i, j):",
		"\t\t\"\"\"",
		"\t\ta[i] + a[i+1] + ... + a[j] を 求める",
		"\t\ti, j は 0-index",
		"\t\t\"\"\"",
		"\t\treturn self.sum(j) - self.sum(i - 1)",
		"",
		"\tdef lower_bound(self, x):",
		"\t\t\"\"\"",
		"\t\ta0 + a1 + ... + ai >= x となる最小のiを取得.",
		"\t\t各項は非負である必要がある",
		"\t\tiは0 - index",
		"\t\t\"\"\"",
		"\t\tif x <= 0:",
		"\t\t\treturn -1",
		"",
		"\t\tk = 1 << (self.size.bit_length() - 1)",
		"\t\tpos = 0",
		"\t\ts = 0",
		"\t\twhile k > 0:",
		"\t\t\t# (pos + kが配列の長さを超えない) and 和がxを超えない",
		"\t\t\tif (pos + k < self.size) and self.tree[pos + k] + s < x:",
		"\t\t\t\ts += self.tree[pos + k]",
		"\t\t\t\tpos += k",
		"\t\t\t# 1つ下の段に行く",
		"\t\t\tk //= 2",
		"\t\treturn pos",
		],
		"description": "Binary Indexed Tree (Fenwick Tree)"
	},
	"compress": {
		"prefix": "compress",
		"body": [
		"def compress(A):",
		"\tB = sorted(set(A))",
		"\tzipped = {}",
		"\tunzipped = {}",
		"\tfor i, x in enumerate(B):",
		"\t\tzipped[x] = i",
		"\t\tunzipped[i] = x",
		"\treturn zipped, unzipped",
		],
		"description": "座標圧縮"
	},
	"Strongly-Connected Components": {
		"prefix": "scc",
		"body": [
		"def scc(N, G, RG):",
		"\t\"\"\"Strongly-Connected Components",
		"",
		"\tArgs:",
		"\t\tN (int): number of vertex_",
		"\t\tG (List[list(int)]): adjacent list",
		"\t\tRG (List[list(int)]): reverse adjacent list",
		"",
		"\t\"\"\"",
		"",
		"\tdef dfs(now):",
		"\t\tseen[now] = 1",
		"\t\tfor to in G[now]:",
		"\t\t\tif not seen[to]:",
		"\t\t\t\tdfs(to)",
		"\t\torder.append(now)",
		"",
		"\tdef rdfs(now, col):",
		"\t\tseen[now] = 1",
		"\t\tgroup[now] = col",
		"\t\tfor to in RG[now]:",
		"\t\t\tif not seen[to]:",
		"\t\t\t\trdfs(to, col)",
		"",
		"\torder, seen = [], [0] * N",
		"",
		"\tfor v in range(N):",
		"\t\tif not seen[v]:",
		"\t\t\tdfs(v)",
		"",
		"\tgroup, seen = [None] * N, [0] * N",
		"\tlabel = 0",
		"\tfor v in order[::-1]:",
		"\t\tif not seen[v]:",
		"\t\t\trdfs(v, label)",
		"\t\t\tlabel += 1",
		"",
		"\treturn label, group",
		],
		"description": "Strongly-Connected Components"
		},
	"combination on Modulo": {
			"prefix": "combination",
			"body": [
			"fact = [1] * (N+1)  # fact[i] = i! % mod",
			"inv = [1] * (N+1)  # inv[i] = i^-1 % mod, factinvの計算用",
			"inv[0] = 0",
			"factinv = [1] * (N+1)  # factinv[i] = (i!)^-1 % mod",
			"",
			"for i in range(2, N+1):",
			"\tfact[i] = (fact[i-1] * i) % mod",
			"\tinv[i] = (-inv[mod % i] * (mod // i)) % mod",
			"\tfactinv[i] = (factinv[i-1] * inv[i]) % mod",
			"",
			"",
			"def cmb_mod(n, r):",
			"\tif (r < 0) or (n < r):",
			"\t\treturn 0",
			"\tr = min(r, n-r)",
			"\treturn fact[n] * factinv[r] * factinv[n-r] % mod",
			],
			"description": "Combination on Modulo"
	},
	"warshall floyd法": {
		"prefix": "warshall_floyd",
		"body": [
		"INF = 10**10",
		"def warshall_floyd(graph):",
		"\tn = len(graph)",
		"\tdist = [[INF] * n for _ in range(n)]",
		"",
		"\t# 初期状態: i -> i は距離0",
		"\tfor i in range(n):",
		"\t\tdist[i][i] = 0",
		"",
		"\t# 初期状態: 隣接頂点のコストをdistに記録する",
		"\tfor now in range(n):",
		"\t\tfor to, cost in graph[now]:",
		"\t\t\tdist[now][to] = cost",
		"",
		"\t# DP",
		"\tfor k in range(n):  # 中継点",
		"\t\tfor i in range(n):  # 始点",
		"\t\t\tfor j in range(n):  # 終点",
		"\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])",
		"\treturn dist",
		],
		"description": "全点対間最短経路"
	},
	"AVL Tree": {
		"prefix": "AVL Tree",
		"body": [
		"class Node:",
		"\t\"\"\"AVL木上の各データを表すノード",
		"",
		"\tAttributes:",
		"\t\tkey (any): ノードのキー. 比較可能である必要がある.",
		"\t\tvalue (any): ノードの値 (保存したいデータ)",
		"\t\tleft (Node): 左の子ノード",
		"\t\tright (Node): 右の子ノード",
		"\t\tbias (int): 平衡度 = (左の部分木の高さ) - (右の部分木の高さ)",
		"\t\tsize (int): 部分木のサイズ（自分を含む）",
		"\t\"\"\"",
		"",
		"\tdef __init__(self, key, value):",
		"\t\tself.key = key",
		"\t\tself.value = value",
		"\t\tself.left = None",
		"\t\tself.right = None",
		"\t\tself.bias = 0",
		"\t\tself.size = 1",
		"",
		"\tdef __repr__(self):",
		"\t\treturn str(self.value)",
		"",
		"",
		"class AVLTree:",
		"\t\"\"\"AVL木: 非再帰, 重複無し",
		"",
		"\tAttributes:",
		"\t\troot (Node): 根ノード. default to None",
		"\t\"\"\"",
		"",
		"\tdef __init__(self):",
		"\t\tself.root = None",
		"",
		"\tdef _rotateL(self, u: Node):",
		"\t\t\"\"\"uに対する左1重回転",
		"",
		"\t\tArgs:",
		"\t\t\tu (Node): 左回転を行う部分木",
		"",
		"\t\tReturns:",
		"\t\t\tNode: 左回転をした結果の部分木",
		"\t\t\"\"\"",
		"\t\tv = u.right",
		"",
		"\t\t# sizeの修正",
		"\t\tv.size = u.size",
		"\t\tu.size -= (v.right.size + 1) if v.right is not None else 1",
		"",
		"\t\t# 繋ぎ変え",
		"\t\tu.right = v.left",
		"\t\tv.left = u",
		"",
		"\t\t# biasの修正",
		"\t\tif v.bias == -1:",
		"\t\t\tv.bias = u.bias = 0",
		"\t\telse:",
		"\t\t\tv.bias = 1",
		"\t\t\tu.bias = -1",
		"\t\treturn v",
		"",
		"\tdef _rotateR(self, u: Node):",
		"\t\t\"\"\"uに対する右1重回転",
		"",
		"\t\tArgs:",
		"\t\t\tu (Node): 右回転を行う部分木",
		"",
		"\t\tReturns:",
		"\t\t\tNode: 右回転をした結果の部分木",
		"\t\t\"\"\"",
		"\t\tv = u.left",
		"",
		"\t\t# sizeの修正",
		"\t\tv.size = u.size",
		"\t\tu.size -= (v.left.size + 1) if v.left is not None else 1",
		"",
		"\t\t# 繋ぎ変え",
		"\t\tu.left = v.right",
		"\t\tv.right = u",
		"",
		"\t\t# biasの修正",
		"\t\tif v.bias == 1:",
		"\t\t\tv.bias = u.bias = 0",
		"\t\telse:",
		"\t\t\tv.bias = -1",
		"\t\t\tu.bias = 1",
		"\t\treturn v",
		"",
		"\tdef _update_bias(self, u: Node):",
		"\t\t\"\"\"2重回転後のbiasの変更",
		"",
		"\t\tArgs:",
		"\t\t\tu (Node): 2重回転後の部分木",
		"\t\t\"\"\"",
		"\t\tif u.bias == 1:",
		"\t\t\tu.right.bias = -1",
		"\t\t\tu.left.bias = 0",
		"\t\telif u.bias == -1:",
		"\t\t\tu.right.bias = 0",
		"\t\t\tu.left.bias = 1",
		"\t\telse:",
		"\t\t\tu.right.bias = 0",
		"\t\t\tu.left.bias = 0",
		"\t\tu.bias = 0",
		"",
		"\tdef _rotateLR(self, u: Node):",
		"\t\t\"\"\"uに対する左・右2重回転",
		"",
		"\t\tArgs:",
		"\t\t\tu (Node): 対象の部分木",
		"",
		"\t\tReturns:",
		"\t\t\tNode: 左・右回転をした結果の部分木",
		"\t\t\"\"\"",
		"\t\tv = u.left",
		"\t\tw = v.right",
		"",
		"\t\t# sizeの修正",
		"\t\tw.size = u.size",
		"\t\tu.size -= (v.size) - (w.right.size if w.right is not None else 0)",
		"\t\tv.size -= (w.right.size + 1 if w.right is not None else 1)",
		"",
		"\t\t# vに対して左回転",
		"\t\tv.right = w.left",
		"\t\tw.left = v",
		"",
		"\t\t# uに対して右回転",
		"\t\tu.left = w.right",
		"\t\tw.right = u",
		"",
		"\t\t# biasの変更",
		"\t\tself._update_bias(w)",
		"\t\treturn w",
		"",
		"\tdef _rotateRL(self, u: Node):",
		"\t\t\"\"\"uに対する右・左2重回転",
		"",
		"\t\tArgs:",
		"\t\t\tu (Node): 対象の部分木",
		"",
		"\t\tReturns:",
		"\t\t\tNode: 右・左回転をした結果の部分木",
		"\t\t\"\"\"",
		"\t\tv = u.right",
		"\t\tw = v.left",
		"",
		"\t\t# sizeの修正",
		"\t\tw.size = u.size",
		"\t\tu.size -= (v.size) - (w.left.size if w.left is not None else 0)",
		"\t\tv.size -= (w.left.size + 1 if w.left is not None else 1)",
		"",
		"\t\t# vに対して右回転",
		"\t\tv.left = w.right",
		"\t\tw.right = v",
		"",
		"\t\t# nodeに対して左回転",
		"\t\tu.right = w.left",
		"\t\tw.left = u",
		"",
		"\t\t# biasの変更",
		"\t\tself._update_bias(w)",
		"\t\treturn w",
		"",
		"\tdef _balance(self, path: list, t: int):",
		"\t\t\"\"\"path上の頂点の回転を行う",
		"",
		"\t\tArgs:",
		"\t\t\tpath (List[Node, int]): 回転を行うパス上の頂点",
		"\t\t\tt (int): deleteのとき-1, insertのとき1",
		"",
		"\t\tNote:",
		"\t\t\t- 高さが変わると, その後のnodeで修正が必要になる",
		"\t\t\t- |bias| = 2 なら, 回転が必要になる",
		"\t\t\"\"\"",
		"\t\tchild = None",
		"\t\tactive = True",
		"\t\twhile path:",
		"\t\t\tu, direction = path.pop()",
		"\t\t\tu.size += t",
		"",
		"\t\t\t# 回転などにより, 子に変更があったら繋ぎ変える",
		"\t\t\tif child is not None:",
		"\t\t\t\tif direction == 1:",
		"\t\t\t\t\tu.left = child",
		"\t\t\t\telse:",
		"\t\t\t\t\tu.right = child",
		"",
		"\t\t\t\t# 削除: |bias| = 1 なら その後も平衡",
		"\t\t\t\tif (child.bias != 0) and (t == -1):",
		"\t\t\t\t\tactive = False",
		"",
		"\t\t\t\t# 挿入: 回転後のbiasが0になる",
		"\t\t\t\tif (child.bias == 0) and (t == 1):",
		"\t\t\t\t\tactive = False",
		"",
		"\t\t\t\tchild = None",
		"",
		"\t\t\tif active:",
		"\t\t\t\tu.bias += t * direction",
		"\t\t\telse:",
		"\t\t\t\tcontinue",
		"",
		"\t\t\t# 挿入: bias=0 なら以降変更必要なし",
		"\t\t\tif (u.bias == 0) and (t == 1):",
		"\t\t\t\tactive = False",
		"",
		"\t\t\t# 削除: |bias|=1 なら以降変更必要なし",
		"\t\t\telif (abs(u.bias) == 1) and (t == -1):",
		"\t\t\t\tactive = False",
		"",
		"\t\t\t# 要右回転: 2重回転後の",
		"\t\t\telif u.bias == 2:",
		"\t\t\t\tif u.left.bias == -1:",
		"\t\t\t\t\tchild = self._rotateLR(u)",
		"\t\t\t\telse:",
		"\t\t\t\t\tchild = self._rotateR(u)",
		"",
		"\t\t\t# 要回転",
		"\t\t\telif u.bias == -2:",
		"\t\t\t\tif u.right.bias == 1:",
		"\t\t\t\t\tchild = self._rotateRL(u)",
		"\t\t\t\telse:",
		"\t\t\t\t\tchild = self._rotateL(u)",
		"",
		"\t\tif child is not None:",
		"\t\t\tself.root = child",
		"",
		"\tdef _search(self, key):",
		"\t\t\"\"\"対象のkeyの場所までのpathを探索する",
		"",
		"\t\tArgs:",
		"\t\t\tkey (any): 探索対象のkey",
		"\t\t\"\"\"",
		"\t\tnow = self.root",
		"\t\tpath = []",
		"\t\twhile now is not None:",
		"\t\t\tif key < now.key:  # 左の子へ進む",
		"\t\t\t\tpath.append((now, 1))",
		"\t\t\t\tnow = now.left",
		"\t\t\telif now.key < key:  # 右の子へ進む",
		"\t\t\t\tpath.append((now, -1))",
		"\t\t\t\tnow = now.right",
		"\t\t\telif now.key == key:  # 終了",
		"\t\t\t\tpath.append((now, 0))",
		"\t\t\t\tbreak",
		"\t\treturn path",
		"",
		"\tdef insert(self, key, value=None):",
		"\t\t\"\"\"値の挿入",
		"",
		"\t\tArgs:",
		"\t\t\tkey (any): データのkey",
		"\t\t\tvalue (any): keyに対応するデータ",
		"",
		"\t\tNote:",
		"\t\t\t同じkeyが存在する場合, valueを上書きする",
		"\t\t\tdefaultでは, key=value としている",
		"\t\t\"\"\"",
		"\t\tif value is None:",
		"\t\t\tvalue = key",
		"",
		"\t\t# 空のAVLだったら, 根に追加する",
		"\t\tif self.root is None:",
		"\t\t\tself.root = Node(key, value)",
		"\t\t\treturn",
		"",
		"\t\t# 挿入場所までのpathを取得",
		"\t\tpath = self._search(key)",
		"",
		"\t\t# keyが同じモノが存在すれば, 値の上書き",
		"\t\tnow, direction = path[-1]",
		"\t\tif direction == 0:",
		"\t\t\tnow.value = value",
		"\t\t\treturn",
		"",
		"\t\t# 挿入",
		"\t\tif direction == 1:",
		"\t\t\tnow.left = Node(key, value)",
		"\t\telse:",
		"\t\t\tnow.right = Node(key, value)",
		"",
		"\t\t# 回転",
		"\t\tself._balance(path, 1)",
		"",
		"\tdef delete(self, key):",
		"\t\t\"\"\"keyの削除",
		"",
		"\t\tArgs:",
		"\t\t\tkey (any): 削除対象のキー",
		"",
		"\t\tReturns:",
		"\t\t\tany: 削除するkeyのvalue. 削除keyが存在しなければNone",
		"\t\t\"\"\"",
		"\t\tpath = self._search(key)",
		"",
		"\t\t# keyが存在しないとき",
		"\t\tif not path:",
		"\t\t\treturn None",
		"",
		"\t\trm_node, direction = path.pop()",
		"\t\tif direction != 0:",
		"\t\t\treturn None",
		"",
		"\t\trm_value = rm_node.value",
		"",
		"\t\t# 削除ノードが左部分木を持つ場合, 左部分木の最大値ノードと交換してから削除",
		"\t\tif rm_node.left is not None:",
		"\t\t\tpath.append((rm_node, 1))",
		"\t\t\tleft_max = rm_node.left",
		"\t\t\twhile left_max.right is not None:",
		"\t\t\t\tpath.append((left_max, -1))",
		"\t\t\t\tleft_max = left_max.right",
		"",
		"\t\t\t# 左部分木の最大ノードに付いたら, nowと交換",
		"\t\t\trm_node.key = left_max.key",
		"\t\t\trm_node.value = left_max.value",
		"",
		"\t\t\trm_node = left_max",
		"",
		"\t\t# rm_node: 削除ノード",
		"\t\t# child: 削除ノードの子ノード",
		"\t\tchild = rm_node.right if rm_node.left is None else rm_node.left",
		"",
		"\t\t# 削除ノードが根の場合",
		"\t\tif not path:",
		"\t\t\tself.root = child",
		"\t\t\treturn rm_value",
		"",
		"\t\t# 削除 & 繋ぎ変え",
		"\t\tpar, direction = path[-1]",
		"\t\tif direction == 1:",
		"\t\t\tpar.left = child",
		"\t\telse:",
		"\t\t\tpar.right = child",
		"",
		"\t\t# 回転",
		"\t\tself._balance(path, -1)",
		"\t\treturn rm_value",
		"",
		"\tdef member(self, key):",
		"\t\t\"\"\"keyの存在判定",
		"",
		"\t\tArgs:",
		"\t\t\tkey (any): 存在判定するキー",
		"",
		"\t\tReturns:",
		"\t\t\tbool: keyが存在するかどうか",
		"\t\t\"\"\"",
		"\t\tpath = self._search(key)",
		"\t\tif not path:",
		"\t\t\treturn False",
		"",
		"\t\treturn key == path[-1][0].key",
		"",
		"\tdef get(self, key):",
		"\t\t\"\"\"keyのvalueを返す. keyが存在しなければ None を返す",
		"",
		"\t\tArgs:",
		"\t\t\tkey (nay): 検索対象のkey",
		"",
		"\t\tReturns:",
		"\t\t\tany: 指定したキーに付随するvalue. 存在しなければNone",
		"\t\t\"\"\"",
		"\t\tpath = self._search(key)",
		"\t\tif not path:",
		"\t\t\treturn None",
		"",
		"\t\treturn path[-1][0].value if path[-1][0].key == key else None",
		"",
		"\tdef lower_bound(self, key):",
		"\t\t\"\"\"下限探索",
		"",
		"\t\t指定したkey以上のモノの中で, 最小のキーを見つける",
		"",
		"\t\tArgs:",
		"\t\t\tkey (any): キーの下限",
		"",
		"\t\tReturns:",
		"\t\t\tany: 条件を満たすキー. 存在しないならNone.",
		"\t\t\"\"\"",
		"\t\tlower = float(\"inf\")",
		"\t\tnow = self.root",
		"\t\twhile now is not None:",
		"\t\t\tif now.key >= key:",
		"\t\t\t\tlower = min(lower, now.key)",
		"\t\t\t\tnow = now.left",
		"\t\t\telse:",
		"\t\t\t\tnow = now.right",
		"\t\treturn lower if lower != float(\"inf\") else None",
		"",
		"\tdef upper_bound(self, key):",
		"\t\t\"\"\"上限探索",
		"",
		"\t\t指定したkey\"未満\"のモノの中で, 最大のキーを見つける",
		"",
		"\t\tArgs:",
		"\t\t\tkey (any): キーの上限",
		"",
		"\t\tReturns:",
		"\t\t\tany: 条件を満たすキー. 存在しないならNone.",
		"\t\t\"\"\"",
		"\t\tupper = -float(\"inf\")",
		"\t\tnow = self.root",
		"\t\twhile now is not None:",
		"\t\t\tif now.key < key:",
		"\t\t\t\tupper = max(upper, now.key)",
		"\t\t\t\tnow = now.right",
		"\t\t\telse:",
		"\t\t\t\tnow = now.left",
		"\t\treturn upper if upper != -float(\"inf\") else None",
		"",
		"\tdef kth_element(self, k):",
		"\t\t\"\"\"小さい方からk番目の要素を見つける",
		"",
		"\t\tArgs:",
		"\t\t\tk (int): 何番目か (0-index)",
		"",
		"\t\tNote:",
		"\t\t\t要素がk未満なら, Noneを返す",
		"",
		"\t\tReturns:",
		"\t\t\tany: 条件を満たすkey",
		"\t\t\"\"\"",
		"\t\tnow = self.root",
		"\t\ts = 0",
		"\t\twhile now is not None:",
		"\t\t\tif now.left is not None:",
		"\t\t\t\tt = s + now.left.size",
		"\t\t\telse:",
		"\t\t\t\tt = s",
		"",
		"\t\t\t# s + left < k なら 右の子へ, 違うなら左の子へ",
		"\t\t\tif t == k:",
		"\t\t\t\treturn now.key",
		"\t\t\telif t < k:",
		"\t\t\t\ts = t + 1  # now node 分の +1",
		"\t\t\t\tnow = now.right",
		"\t\t\telse:",
		"\t\t\t\tnow = now.left",
		"",
		"\t\treturn None",
		"",
		"\tdef __contains__(self, key):",
		"\t\treturn self.get(key)",
		"",
		"\tdef __len__(self):",
		"\t\treturn self.root.size if self.root is not None else 0",
		"",
		"\tdef __bool__(self):",
		"\t\treturn self.root is not None",
		"",
		"\tdef __getitem__(self, key):",
		"\t\t# list[1] の ような要素の取得の特殊メソッド",
		"\t\treturn self.get(key)",
		"",
		"\tdef __setitem__(self, key, value):",
		"\t\t# list[1] = 2 の ような要素のセットの特殊メソッド",
		"\t\treturn self.insert(key, value)",
		"",
		"\tdef __delitem__(self, key):",
		"\t\t# del文で呼び出されるメソッド",
		"\t\treturn self.delete(key)",
		"",
		"\tdef __repr__(self):",
		"",
		"\t\tdef dfs(now):",
		"\t\t\tif now is None:",
		"\t\t\t\treturn \"\"",
		"",
		"\t\t\tprint(f\"parent = {now}\")",
		"\t\t\tprint(f\"bias = {now.bias}, size = {now.size}\")",
		"",
		"\t\t\tleft = now.left",
		"\t\t\tright = now.right",
		"\t\t\tprint(f\"left = {left}, right = {right}\")",
		"\t\t\tdfs(left)",
		"\t\t\tdfs(right)",
		"",
		"\t\tdfs(self.root)",
		"\t\treturn \"\"",
		"",
		],
		"description": "AVL木"
	},
	"Segment Tree": {
		"prefix": "Segment Tree",
		"body": [
		"class SegmentTree:",
		"\t\"\"\"1点更新・区間集約 Segment Tree. 非再起・1-index・非可換",
		"",
		"\tAttributes:",
		"\t\ttree (List[Union[int, float]]): セグメントツリーを表す配列",
		"\t\tsegfunc (Callable): 集約を行う関数 (モノイド上の演算)",
		"\t\tide_ele (float): 集約の関数における単位元　（モノイド上の単位元）",
		"\t\tupdate (int, float): 元の配列の更新 & セグメントツリーの更新",
		"\t\tquery (int, int): 区間集約値の取得",
		"\t\"\"\"",
		"",
		"\tdef __init__(self, n: int, ide_ele: float, seg_func: callable):",
		"\t\t\"\"\"",
		"\t\tArgs:",
		"\t\t\tn (int): 元の配列のサイズ",
		"\t\t\tide_ele (float): モノイドにおける単位元",
		"\t\t\tsegfunc (callable): 集約を行う関数 （モノイド上の演算）",
		"\t\t\"\"\"",
		"\t\tself.segfunc = seg_func",
		"\t\tself.ide_ele = ide_ele",
		"\t\tself.num = 1 << (n - 1).bit_length()",
		"\t\tself.tree = [self.ide_ele] * (2 * self.num)",
		"",
		"\tdef update(self, i: int, x: float) -> None:",
		"\t\t\"\"\"元の配列のi番目を x に変更（上書き）する. それに伴ってセグメントツリーも更新する. +=のようなupdateではない.",
		"",
		"\t\tArgs:",
		"\t\t\ti (int): 元の配列のi番目の要素. 元の配列の0-indexの",
		"\t\t\tx (float): 変更後の値",
		"\t\t\"\"\"",
		"\t\ti += self.num",
		"\t\tself.tree[i] = x",
		"\t\twhile i > 1:",
		"\t\t\ti >>= 1",
		"\t\t\tself.tree[i] = self.segfunc(self.tree[i << 1], self.tree[(i << 1) + 1])",
		"",
		"\tdef query(self, l: int, r: int):",
		"\t\t\"\"\"元の配列の閉区間[l, r]のsegfuncにおける集約値を取得する",
		"",
		"\t\tArgs:",
		"\t\t\tl (int): 元の配列の集約を行う区間の左端のindex. 0-index",
		"\t\t\tr (int): 元の配列の集約を行う区間の右端のindex. 0-index",
		"\t\t\"\"\"",
		"\t\t# [l, r) として葉から計算していく",
		"\t\tl += self.num",
		"\t\tr += self.num + 1",
		"",
		"\t\tl_res = self.ide_ele",
		"\t\tr_res = self.ide_ele",
		"",
		"\t\twhile l < r:",
		"\t\t\tif l & 1:  # lが奇数だったらそのノードを集約する",
		"\t\t\t\tl_res = self.segfunc(l_res, self.tree[l])",
		"\t\t\t\tl += 1  # 右に進む",
		"\t\t\tif r & 1:  # rが奇数だったら, rは開区間なので その1つ左ノードを集約する",
		"\t\t\t\tr_res = self.segfunc(self.tree[r - 1], r_res)",
		"",
		"\t\t\tl >>= 1  # 上に進む（２で割って切り捨て）",
		"\t\t\tr >>= 1",
		"",
		"\t\treturn self.segfunc(l_res, r_res)",
		],
		"description": "Segment Tree"
	},
	"MultiSet": {
		"prefix": "MultiSet",
		"body": [
		"from heapq import heappush, heappop",
		"from collections import defaultdict",
		"",
		"",
		"class MultiSet:",
		"\tdef __init__(self):",
		"\t\tself.min_h = []",
		"\t\tself.max_h = []",
		"\t\tself.cnt = defaultdict(int)",
		"",
		"\tdef add(self, x):",
		"\t\theappush(self.min_h, x)",
		"\t\theappush(self.max_h, -x)",
		"\t\tself.cnt[x] += 1",
		"",
		"\tdef remove(self, x, num):",
		"\t\tif self.cnt[x] == 0:",
		"\t\t\treturn",
		"",
		"\t\tself.cnt[x] = max(0, self.cnt[x] - num)",
		"\t\twhile self.min_h:",
		"\t\t\tif self.cnt[self.min_h[0]] == 0:",
		"\t\t\t\theappop(self.min_h)",
		"\t\t\telse:",
		"\t\t\t\tbreak",
		"",
		"\t\twhile self.max_h:",
		"\t\t\tif self.cnt[-1 * self.max_h[0]] == 0:",
		"\t\t\t\theappop(self.max_h)",
		"\t\t\telse:",
		"\t\t\t\tbreak",
		"",
		"\tdef is_exist(self, x):",
		"\t\treturn self.cnt[x] > 0",
		"",
		"\t@property",
		"\tdef min(self):",
		"\t\treturn self.min_h[0]",
		"",
		"\t@property",
		"\tdef max(self):",
		"\t\treturn -1 * self.max_h[0]",
		],
		"description": "min-max MultiSet"
	},
}
